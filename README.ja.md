# 重要なのは認知負荷だ

[読みやすい版](https://minds.md/zakirullin/cognitive) | [中国語翻訳](https://github.com/zakirullin/cognitive-load/blob/main/README.zh-cn.md) | [韓国語翻訳](README.ko.md) | [トルコ語翻訳](README.tr.md)

*これは生きた文書であり、最終更新は**2025年8月**です。あなたの貢献を歓迎します。*

## はじめに
世の中には多くのバズワードやベストプラクティスがありますが、そのほとんどが失敗しています。もっと根本的な、間違えようのないものが必要です。

コードを読んでいて混乱を感じることがあります。混乱は時間とコストを消費します。混乱の原因は高い*認知負荷*にあります。これは決して抽象的な概念ではなく、**人間の根本的な制約**なのです。想像上のものではなく、実際に存在し、私たちはそれを感じることができます。

コードを書くよりもコードを読んで理解することに費やす時間のほうがはるかに長いため、私たちは常に、過度の認知負荷をコードに埋め込んでいないかを自問すべきです。

## 認知負荷
> 認知負荷とは、開発者がタスクを完了するために考える必要がある量のことです。

コードを読むとき、変数の値、制御フローロジック、呼び出しシーケンスなどを頭に入れます。平均的な人はワーキングメモリに約[4つのチャンク](https://github.com/zakirullin/cognitive-load/issues/16)を保持できます。認知負荷がこの閾値に達すると、物事を理解するのがはるかに困難になります。

*完全に馴染みのないプロジェクトにバグ修正を依頼されたとしましょう。とても賢い開発者が貢献していたと聞かされました。多くの洗練されたアーキテクチャ、おしゃれなライブラリ、最新のテクノロジーが使われていました。つまり、**著者は私たちに高い認知負荷を作り出していた**のです。*

<div align="center">
  <img src="/img/cognitiveloadv6.png" alt="認知負荷" width="750">
</div>

私たちはプロジェクトの認知負荷を可能な限り減らすべきです。

<details>
  <summary><b>認知負荷と中断</b></summary>
  <img src="img/interruption.jpeg"><br>
</details>

## 認知負荷の種類
**内発的** - タスクの本来の難易度によって引き起こされます。これは削減できず、ソフトウェア開発の核心にあるものです。

**外発的** - 情報の提示方法によって作り出されます。賢い著者の癖のような、タスクに直接関係しない要因によって引き起こされます。大幅に削減可能です。私たちはこの種の認知負荷に焦点を当てます。

<div align="center">
  <img src="/img/smartauthorv14thanksmari.png" alt="内発的 vs 外発的" width="600">
</div>

外発的認知負荷の具体的で実践的な例にすぐに飛び込みましょう。

---

認知負荷のレベルを以下のように表記します：
`🧠`: 新鮮なワーキングメモリ、認知負荷ゼロ
`🧠++`: ワーキングメモリに2つの事実、認知負荷増加
`🤯`: 認知過負荷、4つ以上の事実

> 私たちの脳ははるかに複雑で未探索ですが、この単純化されたモデルで進めることができます。

## 複雑な条件文
```go
if val > someConstant // 🧠+
    && (condition2 || condition3) // 🧠+++、前の条件が真、c2かc3の一方が真である必要
    && (condition4 && !condition5) { // 🤯、この時点で混乱
    ...
}
```

意味のある名前を持つ中間変数を導入します：
```go
isValid = val > someConstant
isAllowed = condition2 || condition3
isSecure = condition4 && !condition5 
// 🧠、条件を覚える必要がない、記述的な変数がある
if isValid && isAllowed && isSecure {
    ...
}
```

## ネストしたif文
```go
if isValid { // 🧠+、ネストしたコードは有効な入力にのみ適用
    if isSecure { // 🧠++、有効で安全な入力にのみ処理
        stuff // 🧠+++
    }
} 
```

早期リターンと比較してみましょう：
```go
if !isValid
    return
 
if !isSecure
    return

// 🧠、以前のリターンは気にしない、ここにいるということはすべて良好

stuff // 🧠+
```

ハッピーパスだけに集中でき、ワーキングメモリをあらゆる前提条件から解放します。

## 継承の悪夢
管理者ユーザーのためにいくつかの変更を依頼されました：`🧠`

`AdminController extends UserController extends GuestController extends BaseController`

ああ、機能の一部は`BaseController`にあります、見てみましょう：`🧠+`
基本的な役割メカニクスが`GuestController`で導入されました：`🧠++`
`UserController`で部分的に変更されました：`🧠+++`
ついにここに来ました、`AdminController`、コーディングしましょう！`🧠++++`

ああ、待って、`AdminController`を継承する`SuperuserController`があります。`AdminController`を変更することで継承クラスで問題が起こる可能性があるので、まず`SuperuserController`を調べましょう：`🤯`

継承よりコンポジションを好みましょう。詳細には触れません - [十分な資料](https://www.youtube.com/watch?v=hxGOiiR9ZKg)があります。

## 小さなメソッド、クラス、モジュールが多すぎる
> この文脈では、メソッド、クラス、モジュールは交換可能です

「メソッドは15行未満であるべき」や「クラスは小さくあるべき」といった格言は、やや間違っていることが判明しました。

**深いモジュール** - シンプルなインターフェース、複雑な機能
**浅いモジュール** - インターフェースが提供する小さな機能に対して相対的に複雑

<div align="center">
  <img src="/img/deepmodulev8.png" alt="深いモジュール" width="700">
</div>

浅いモジュールが多すぎると、プロジェクトを理解するのが困難になる可能性があります。**各モジュールの責任を頭に置くだけでなく、それらすべてのインタラクションも把握する必要があります**。浅いモジュールの目的を理解するために、まずすべての関連モジュールの機能を調べる必要があります。そのような浅いコンポーネント間をジャンプするのは精神的に疲れます。<a target="_blank" href="https://blog.separateconcerns.com/2023-09-11-linear-code.html">線形思考</a>は私たち人間により自然です。

> 情報隠蔽は最重要であり、浅いモジュールでは複雑性をそれほど隠せません。

私には2つのペットプロジェクトがあり、どちらも約5,000行のコードです。最初のプロジェクトには80の浅いクラスがあり、2番目のプロジェクトには7つの深いクラスしかありませんでした。これらのプロジェクトのメンテナンスを1年半していませんでした。

戻ってきたとき、最初のプロジェクトの80のクラス間のすべてのインタラクションを解きほぐすのが非常に困難であることに気づきました。コーディングを始める前に、膨大な認知負荷を再構築する必要がありました。一方、2番目のプロジェクトは、シンプルなインターフェースを持つ少数の深いクラスしかなかったため、すぐに把握できました。

> 最高のコンポーネントは、強力な機能を提供しながらシンプルなインターフェースを持つものです。
> **John K. Ousterhout**

UNIX I/Oのインターフェースは非常にシンプルです。基本的な呼び出しは5つだけです：
```python
open(path, flags, permissions)
read(fd, buffer, count)
write(fd, buffer, count)
lseek(fd, offset, referencePosition)
close(fd)
```

このインターフェースの現代的な実装は**数十万行のコード**を持ちます。多くの複雑性がフードの下に隠されています。しかし、シンプルなインターフェースのおかげで使いやすいのです。

> この深いモジュールの例は、John K. Ousterhoutの[A Philosophy of Software Design](https://web.stanford.edu/~ouster/cgi-bin/book.php)から取られました。この本はソフトウェア開発における複雑性の本質をカバーするだけでなく、Parnasの影響力のある論文[On the Criteria To Be Used in Decomposing Systems into Modules](https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf)の最高の解釈も提供します。どちらも必読です。関連読み物：[A Philosophy of Software Design vs Clean Code](https://github.com/johnousterhout/aposd-vs-clean-code)、[It's probably time to stop recommending Clean Code](https://qntm.org/clean)、[Small Functions considered Harmful](https://copyconstruct.medium.com/small-functions-considered-harmful-91035d316c29)。

P.S. 責任が多すぎる肥大化したGodオブジェクトを支持していると思われるなら、それは間違いです。

## 一つのことに責任を持つ
あまりにもしばしば、曖昧な「モジュールは一つの、そして唯一の一つのことに責任を持つべき」原則に従って、多くの浅いモジュールを作ることになります。このぼんやりとした「一つのこと」とは何でしょうか？オブジェクトをインスタンス化することは一つのことでしょうか？だから[MetricsProviderFactoryFactory](https://minds.md/benji/frameworks)は問題ないように見えます。**そのようなクラスの名前とインターフェースは、実装全体よりも精神的に負荷が大きくなる傾向があります。それはどのような抽象化でしょうか？** 何かが間違っています。

私たちはユーザーや利害関係者を満足させるためにシステムを変更します。私たちは彼らに対して責任があります。

> モジュールは一つの、そして唯一の一つのユーザーまたは利害関係者に責任を持つべきです。

これが単一責任原則の本質です。簡単に言えば、一箇所にバグを導入して、2人の異なるビジネス関係者が苦情を言いに来た場合、原則に違反しています。モジュールで行うことの数とは関係ありません。

しかし今でも、この規則は害を与える可能性があります。この原則は個人の数だけ異なる方法で理解される可能性があります。より良いアプローチは、それがどのくらいの認知負荷を作り出すかを見ることです。一箇所での変更が異なるビジネスストリーム間で連鎖反応を引き起こす可能性があることを覚えておくのは精神的に負荷が大きいです。それだけのことで、学ぶべき難しい用語はありません。

## 浅いマイクロサービスが多すぎる
この浅い-深いモジュール原則はスケールに依存せず、マイクロサービスアーキテクチャにも適用できます。浅いマイクロサービスが多すぎても良いことはありません - 業界は多少「マクロサービス」、つまりそれほど浅くない（=深い）サービスに向かっています。最悪で修正が困難な現象の一つは、いわゆる分散モノリスで、これはしばしばこの過度に粒度の細かい浅い分離の結果です。

かつて、5人の開発者チームが17個（！）のマイクロサービスを導入したスタートアップをコンサルティングしました。彼らは10ヶ月スケジュールが遅れており、パブリックリリースには程遠い状態でした。新しい要件のたびに4つ以上のマイクロサービスでの変更が必要でした。そのような分散システムで問題を再現しデバッグするには膨大な時間がかかりました。市場投入時間と認知負荷の両方が許容できないほど高かったのです。`🤯`

これは新しいシステムの不確実性に対する正しいアプローチでしょうか？最初に正しい論理的境界を引き出すことは非常に困難です。重要なのは、情報が最も多い時点まで責任を持って待てるだけ決定を遅らせることです。最初にネットワーク層を導入することで、最初から設計決定を元に戻すのを困難にしています。チームの唯一の正当化は：「FAANG企業がマイクロサービスアーキテクチャが効果的であることを証明した」でした。*現実を見ましょう。*

[Tanenbaum-Torvalds討論](https://en.wikipedia.org/wiki/Tanenbaum%E2%80%93Torvalds_debate)では、Linuxのモノリシック設計が欠陥があり時代遅れであり、代わりにマイクロカーネルアーキテクチャを使うべきだと主張されました。確かに、マイクロカーネル設計は「理論的で美的な」観点から優れているように見えました。実用的な側面では - 30年経った今、マイクロカーネルベースのGNU Hurdはまだ開発中で、モノリシックなLinuxがどこにでもあります。このページはLinuxで動いており、あなたのスマートティーポットもLinuxで動いています。モノリシックなLinuxで。

本当に分離されたモジュールを持つ良く作られたモノリスは、多くのマイクロサービスよりもはるかに柔軟であることが多いです。また、維持するのに必要な認知的努力もはるかに少なくなります。開発チームのスケーリングなど、別々のデプロイメントの必要性が重要になった場合にのみ、モジュール間、将来のマイクロサービス間にネットワーク層を追加することを検討すべきです。

## 機能豊富な言語
お気に入りの言語で新機能がリリースされるとワクワクします。これらの機能を学ぶのに時間を費やし、その上にコードを構築します。

多くの機能がある場合、数行のコードで30分を費やして、ある機能を使うか別の機能を使うかを考えるかもしれません。それは時間の無駄です。しかし、もっと悪いことに、**後で戻ってきたときに、その思考プロセスを再現する必要があります！**

**この複雑なプログラムを理解するだけでなく、利用可能な機能から問題にアプローチするこの方法をプログラマーがなぜ決定したのかを理解する必要があります。** `🤯`

これらの発言は他ならぬRob Pikeによるものです。

> 選択肢の数を制限して認知負荷を減らす。

言語機能は、お互いに直交している限り問題ありません。

<details>
  <summary><b>20年のC++経験を持つエンジニアからの考え ⭐️</b></summary>
  <br>
  先日RSSリーダーを見ていると、「C++」タグの下に未読記事が約300個あることに気づきました。昨年の夏以降、この言語についての記事を一つも読んでおらず、気分は良好です！<br><br>
  私は20年間C++を使っており、それは人生の約3分の2です。私の経験の大部分は、言語の最も暗い部分（あらゆる種類の未定義動作など）を扱うことにあります。それは再利用可能な経験ではなく、今それをすべて捨てるのはちょっと不気味です。<br><br>
  例えば、トークン<code>||</code>が<code>requires ((!P&lt;T&gt; || !Q&lt;T&gt;))</code>と<code>requires (!(P&lt;T&gt; || Q&lt;T&gt;))</code>で異なる意味を持つことを想像できますか。最初は制約分離、2番目は昔ながらの論理OR演算子で、これらは異なる動作をします。<br><br>
  自明な型のためのスペースを割り当て、そこに一連のバイトを<code>memcpy</code>するだけでは、追加の努力なしにはオブジェクトの生存期間を開始できません。これはC++20以前の場合でした。C++20で修正されましたが、言語の認知負荷は増加しただけです。<br><br>
  物事が修正されても認知負荷は常に増加しています。私はプロとして、何が修正されたか、いつ修正されたか、以前はどうだったかを知っている必要があります。確かに、C++はレガシーサポートが得意で、それはあなたが<b>そのレガシーに直面する</b>ことも意味します。例えば、先月同僚がC++03でのある動作について尋ねました。<code>🤯</code><br><br>
  初期化の方法は20通りありました。統一初期化構文が追加されました。今は21通りの初期化方法があります。ところで、初期化リストからコンストラクタを選択する規則を覚えていますか？情報の損失が最小の暗黙変換についてのもので、<i>しかし値が静的に分かっている場合は</i>、それから... <code>🤯</code><br><br>
  <b>この増加した認知負荷は、手元のビジネスタスクによるものではありません。それはドメインの本質的な複雑性ではありません。歴史的な理由で存在しているだけです</b>（<i>外発的認知負荷</i>）。<br><br>
  私はいくつかのルールを決める必要がありました。例えば、そのコード行が明らかでなく、標準を覚えなければならない場合は、そのように書かないほうが良いです。ちなみに、標準は約1500ページの長さです。<br><br>
  <b>決してC++を非難しようとしているのではありません。</b>私はこの言語を愛しています。ただ、今は疲れているのです。<br><br>
  <p><a href="https://0xd34df00d.me" target="_blank">0xd34df00d</a>に執筆していただき、ありがとうございます。</p>
</details>

## ビジネスロジックとHTTPステータスコード
バックエンドで以下を返します：
`401` 期限切れjwtトークンの場合
`403` アクセス権限不足の場合
`418` 禁止されたユーザーの場合

フロントエンドのエンジニアは、バックエンドAPIを使用してログイン機能を実装します。彼らは一時的に以下の認知負荷を脳内で作成する必要があります：
`401`は期限切れjwtトークンの場合 // `🧠+`、一時的に覚えておく
`403`はアクセス権限不足の場合 // `🧠++`
`418`は禁止されたユーザーの場合 // `🧠+++`

フロントエンド開発者は（願わくば）彼らの側で何らかの`数値ステータス -> 意味`辞書を導入し、後続の貢献者世代がこのマッピングを脳内で再作成する必要がないようにするでしょう。

それからQAエンジニアが登場します：
「やあ、`403`ステータスを受け取ったけど、これは期限切れトークンなの、それともアクセス権限不足なの？」
**QAエンジニアは、バックエンドのエンジニアがかつて作成した認知負荷を再作成しなければならないので、すぐにテストに飛び込むことができません。**

なぜこのカスタムマッピングをワーキングメモリに保持するのでしょうか？ビジネス詳細をHTTP転送プロトコルから抽象化し、レスポンスボディに自己記述的なコードを直接返すほうが良いです：
```json
{
    "code": "jwt_has_expired"
}
```

フロントエンド側の認知負荷：`🧠`（新鮮、頭に保持される事実なし）
QA側の認知負荷：`🧠`

同じ規則があらゆる数値ステータス（データベースやその他の場所）に適用されます - **自己記述的な文字列を好みましょう**。メモリを最適化するための640Kコンピューターの時代ではありません。

> 人々は`401`と`403`の間で議論し、自分の心的モデルに基づいて決定を下すのに時間を費やします。新しい開発者が入ってきて、その思考プロセスを再作成する必要があります。コードの「なぜ」（ADR）を文書化して、新参者が下された決定を理解できるようにしているかもしれません。しかし結局のところ、それは全く意味をなしません。エラーをユーザー関連またはサーバー関連に分離することはできますが、それ以外は物事がぼやけています。

P.S. 「認証」と「認可」を区別するのはしばしば精神的に負荷が大きいです。認知負荷を減らすために、[「ログイン」と「権限」](https://ntietz.com/blog/lets-say-instead-of-auth/)のようなより簡単な用語を使うことができます。

## DRY原則の乱用

Don't repeat yourself（自分を繰り返すな） - これはソフトウェアエンジニアとして教わる最初の原則の一つです。それは私たち自身に深く埋め込まれており、数行の余分なコードの存在に耐えられません。一般的には良い基本的な規則ですが、使いすぎると私たちが処理できない認知負荷につながります。

今日では、誰もが論理的に分離されたコンポーネントに基づいてソフトウェアを構築しています。多くの場合、これらは別々のサービスを表す複数のコードベースに分散されています。あらゆる繰り返しを排除しようと努力すると、関連のないコンポーネント間で密結合を作り出すことになるかもしれません。結果として、一部の変更は他の一見関係のない領域で予期しない結果をもたらす可能性があります。また、システム全体に影響を与えることなく個々のコンポーネントを置き換えたり変更したりする能力を妨げることもあります。`🤯`

実際、同じ問題は単一のモジュール内でも発生します。長期的に実際には存在しないかもしれない認識された類似性に基づいて、共通機能を早すぎる段階で抽出するかもしれません。これは変更や拡張が困難な不要な抽象化をもたらす可能性があります。

Rob Pikeはかつて言いました：

> 少しの依存よりも少しのコピーのほうが良い。

車輪を再発明しないことに強くて惑わされ、私たち自身で簡単に書けるような小さな関数を使うために大きくて重いライブラリをインポートする準備ができています。

**すべての依存関係はあなたのコードです。** インポートされたライブラリの10以上のレベルのスタックトレースを通して何が悪かったかを把握する（*物事は悪化するから*）のは苦痛です。

## フレームワークとの密結合
フレームワークには多くの「魔法」があります。フレームワークに過度に依存することで、**すべての今後の開発者にその「魔法」を最初に学ばせることを強制します**。それには数ヶ月かかることがあります。フレームワークによって数日でMVPを起動できますが、長期的にはそれらは不要な複雑性と認知負荷を追加する傾向があります。

さらに悪いことに、ある時点でフレームワークは、アーキテクチャに合わない新しい要件に直面したときに重大な制約となる可能性があります。ここから人々はフレームワークをフォークして独自のカスタム版を維持することになります。新参者が価値を提供するためにどのくらいの認知負荷を構築（つまり、このカスタムフレームワークを学習）する必要があるか想像してみてください。`🤯`

**決してすべてをゼロから発明することを提唱しているのではありません！**

私たちは多少フレームワークに依存しない方法でコードを書くことができます。ビジネスロジックはフレームワーク内に存在すべきではありません。むしろ、フレームワークのコンポーネントを使用すべきです。フレームワークをコアロジックの外側に置きます。フレームワークをライブラリのような方法で使用します。これにより、新しい貢献者はまずフレームワーク関連の複雑性の残骸を通過する必要なしに、初日から価値を追加できるようになります。

> [Why I Hate Frameworks](https://minds.md/benji/frameworks)

## レイヤードアーキテクチャ
このすべてのことについて、ある種のエンジニアリングの興奮があります。

私自身、何年もヘキサゴナル/オニオンアーキテクチャの情熱的な提唱者でした。あちこちで使用し、他のチームにも勧めました。プロジェクトの複雑性が上がり、ファイル数だけでも倍増しました。多くの糊コードを書いているように感じました。絶え間なく変化する要件に対して、複数の抽象化レイヤーにわたって変更を行う必要があり、それはすべて退屈になりました。`🤯`

抽象化は複雑性を隠すことになっていますが、ここではただ[間接性](https://fhur.me/posts/2024/thats-not-an-abstraction)を追加しているだけです。何が悪くて何が欠けているかを読み進めて把握するために呼び出しから呼び出しへとジャンプするのは、問題を迅速に解決するための重要な要件です。このアーキテクチャのレイヤー分離では、障害が発生するポイントにたどり着くために指数関数的に余分で、しばしばばらばらなトレースが必要です。そのようなトレースはそれぞれ、私たちの限られたワーキングメモリのスペースを占有します。`🤯`

このアーキテクチャは最初は直感的に理にかなっているように見えましたが、プロジェクトに適用しようとするたびに、良いことよりもはるかに害をなしました。最終的に、古き良き依存性逆転原則を支持して、すべてを諦めました。**学ぶべきポート/アダプター用語なし、不要な水平抽象化レイヤーなし、外発的認知負荷なし。**

<details>
  <summary><b>コーディング原則と経験</b></summary>
  <img src="img/complexity.png"><br>
  <a href="https://twitter.com/flaviocopes">@flaviocopes</a>
</details>

そのような階層化によってデータベースや他の依存関係を迅速に置き換えることができると思うなら、それは間違いです。ストレージを変更すると多くの問題が発生し、信じてください、データアクセス層にいくつかの抽象化を持つことは最小の心配事です。せいぜい、抽象化は移行時間の約10％（もしあれば）を節約できますが、実際の痛みはデータモデルの非互換性、通信プロトコル、分散システムの課題、そして[暗黙のインターフェース](https://www.hyrumslaw.com)にあります。

> APIの十分なユーザー数があれば、
> 契約で何を約束しようと関係ありません：
> システムのすべての観察可能な動作が
> 誰かによって依存されます。

私たちはストレージ移行を行い、約10ヶ月かかりました。古いシステムはシングルスレッドだったので、公開されるイベントは順次でした。私たちのすべてのシステムがその観察された動作に依存していました。この動作はAPIコントラクトの一部ではなく、コードに反映されていませんでした。新しい分散ストレージにはその保証がありませんでした - イベントは順不同で来ました。抽象化のおかげで、新しいストレージアダプターのコーディングには数時間しかかかりませんでした。**順不同イベントやその他の課題への対処に次の10ヶ月を費やしました。** 抽象化がコンポーネントを迅速に置き換える助けになるというのは今では面白いことです。

**では、そのようなレイヤードアーキテクチャの高い認知負荷の代価を支払うのはなぜでしょうか、それが将来報われないのであれば？** さらに、ほとんどの場合、いくつかのコアコンポーネントを置き換えるその未来は決して起こりません。

これらのアーキテクチャは基本的ではなく、より基本的な原則の主観的で偏った結果にすぎません。なぜそれらの主観的な解釈に依存するのでしょうか？代わりに基本的な規則に従いましょう：依存性逆転原則、単一の真実の源、認知負荷、情報隠蔽。私たちのビジネスロジックは、データベース、UI、フレームワークなどの低レベルモジュールに依存すべきではありません。インフラストラクチャを心配することなくコアロジックのテストを書けるべきで、それだけです。[議論](https://github.com/zakirullin/cognitive-load/discussions/24)。

アーキテクチャのために抽象化レイヤーを追加してはいけません。実用的な理由で正当化される拡張ポイントが必要なときにそれらを追加しましょう。

**[抽象化レイヤーは無料ではありません](https://blog.jooq.org/why-you-should-not-implement-layered-architecture)、それらは私たちの限られたワーキングメモリに保持される必要があります**。

<div align="center">
  <img src="/img/layers.png" alt="レイヤー" width="400">
</div>

## ドメイン駆動設計
ドメイン駆動設計にはいくつかの素晴らしいポイントがありますが、しばしば誤解されています。人々は「私たちはDDDでコードを書く」と言いますが、これは少し奇妙です。なぜならDDDはソリューション空間よりも問題空間に関するものだからです。

ユビキタス言語、ドメイン、境界づけられたコンテキスト、集約、イベントストーミングはすべて問題空間に関するものです。それらはドメインについての洞察を学び、境界を抽出するのを助けることを意図しています。DDDは開発者、ドメインエキスパート、ビジネス関係者が単一の統一された言語を使って効果的にコミュニケーションを取ることを可能にします。DDDのこれらの問題空間の側面に焦点を当てる代わりに、私たちは特定のフォルダ構造、サービス、リポジトリ、その他のソリューション空間技術を強調する傾向があります。

私たちがDDDを解釈する方法が独特で主観的である可能性があります。そして、この理解の上にコードを構築する場合、つまり、多くの外発的認知負荷を作り出す場合 - 将来の開発者は運命づけられています。`🤯`

Team Topologiesは、認知負荷をチーム間で分割するのに役立つはるかに良い、理解しやすいフレームワークを提供します。エンジニアはTeam Topologiesについて学んだ後、多少似たような心的モデルを開発する傾向があります。一方、DDDは10人の異なる読者に対して10の異なる心的モデルを作り出すように見えます。共通の基盤になる代わりに、不要な議論の戦場になります。

## 馴染みのあるプロジェクトでの認知負荷

> 問題は、**馴染みやすさが単純さと同じではない**ことです。それらは同じように*感じます* - 同じような精神的努力なしに空間を移動するその同じ容易さ - しかし非常に異なる理由によるものです。あなたが使用するすべての「賢い」（読む：「自己満足的な」）で非慣用的なトリックは、他のすべての人に学習ペナルティを課します。彼らがその学習を行うと、コードを扱うのが困難でなくなります。だから、すでに馴染みのあるコードを簡潔にする方法を認識するのは困難です。これが私が「新人」にあまりにも制度化される前にコードを批評してもらうようにする理由です！
>
> 前の著者がこの巨大な混乱を一度にではなく、一つの小さな増分ずつ作り出した可能性があります。だから、あなたが一度にすべてを理解しようとする最初の人なのです。
>
> 私のクラスでは、ある日見ていた広がりのあるSQL格納プロシージャを説明します。巨大なWHERE句に何百行の条件文がありました。誰かがどうしてこんなにひどくなるのを許したのかと尋ねました。私は彼らに言いました：「2つや3つの条件しかないときに、もう一つ追加してもどんな違いも生みません。20や30の条件があるときに、もう一つ追加してもどんな違いも生みません！」
>
> あなたが行う意図的な選択以外に、コードベースに作用する「簡素化力」はありません。簡素化には努力が必要で、人々はあまりにもしばしば急いでいます。
>
> *[Dan North](https://dannorth.net)のコメントに感謝*。

プロジェクトの心的モデルを長期記憶に内在化していれば、高い認知負荷を経験することはないでしょう。

<div align="center">
  <img src="/img/mentalmodelsv15.png" alt="心的モデル" width="700">
</div>

学ぶべき心的モデルが多いほど、新しい開発者が価値を提供するのに時間がかかります。

プロジェクトに新しい人をオンボードするときは、彼らが持つ混乱の量を測定してみてください（ペアプログラミングが役立つかもしれません）。40分以上連続して混乱している場合 - コードで改善すべきことがあります。

認知負荷を低く保てば、人々は会社に参加してから最初の数時間以内にコードベースに貢献できます。

## 例
- 私たちのアーキテクチャは標準的なCRUDアプリアーキテクチャ、[PostgreSQLの上のPythonモノリス](https://danluu.com/simple-architectures/)
- Instagramが[わずか3人のエンジニア](https://read.engineerscodex.com/p/how-instagram-scaled-to-14-million)で1400万ユーザーまでスケールした方法
- 私たちが「うわあ、この人たちは[めちゃくちゃ賢い](https://kenkantzer.com/learnings-from-5-years-of-tech-startup-code-audits/)」と思った企業の大部分は失敗した
- システム全体を配線する一つの関数。システムがどのように動作するかを知りたいなら - [それを読みに行く](https://www.infoq.com/presentations/8-lines-code-refactoring)

これらのアーキテクチャは非常に退屈で理解しやすいです。誰でも大きな精神的努力なしにそれらを把握できます。

アーキテクチャレビューにジュニア開発者を関与させましょう。彼らは精神的に負荷の大きい領域を特定するのに役立ちます。

**ソフトウェアの維持は困難です**、物事は壊れ、節約できるすべての精神的努力が必要になります。

## 結論
第2章で推論したことが実際には真実ではないと一瞬想像してみてください。もしそうなら、私たちが否定した結論、および有効なものとして受け入れた前章の結論も正しくない可能性があります。`🤯`

感じますか？記事全体を飛び回って意味を得なければならないだけでなく（浅いモジュール！）、段落は一般的に理解が困難です。私たちはあなたの頭の中に不要な認知負荷を作り出しました。**同僚にこのようなことをしてはいけません。**

<div align="center">
  <img src="/img/smartauthorv14thanksmari.png" alt="賢い著者" width="600">
</div>

私たちが行う仕事の本質的なものを超えるあらゆる認知負荷を減らすべきです。

---
[LinkedIn](https://www.linkedin.com/in/zakirullin/)、[X](https://twitter.com/zakirullin)、[GitHub](https://github.com/zakirullin)

[読みやすい版](https://minds.md/zakirullin/cognitive)

<details>
    <summary><b>コメント</b></summary>
    <br>
    <p><strong>Rob Pike</strong><br>良い記事です。</p>
    <p><strong><a href="https://x.com/karpathy/status/1872038630405054853" target="_blank">Andrej Karpathy</a></strong> <i>(ChatGPT、Tesla)</i><br>ソフトウェアエンジニアリングに関する良い投稿。おそらく最も真実で、最も実践されていない観点。</p>
    <p><strong><a href="https://x.com/elonmusk/status/1872346903792566655" target="_blank">Elon Musk</a></strong><br>真実だ。</p>
    <p><strong><a href="https://www.linkedin.com/feed/update/urn:li:activity:7277757844970520576/" target="_blank">Addy Osmani</a></strong> <i>(Chrome、世界で最も複雑なソフトウェアシステム)</i><br>賢い開発者が最新の設計パターンとマイクロサービスを使って印象的なアーキテクチャを作成した無数のプロジェクトを見てきました。しかし、新しいチームメンバーが変更を加えようとしたとき、すべてがどのように組み合わさるかを理解するのに何週間も費やしました。認知負荷がとても高く、生産性が急落し、バグが倍増しました。</p>
    <p>皮肉なことに？これらの複雑性を誘発するパターンの多くは「クリーンコード」の名の下に実装されていました。</p>
    <p>本当に重要なのは、不要な認知的負担を減らすことです。時には多くの浅いモジュールではなく、より少ない深いモジュールを意味することもあります。時には小さな関数に分割するのではなく、関連するロジックを一緒に保つことを意味することもあります。</p>
    <p>そして時には賢いものよりも退屈で素直な解決策を選ぶことを意味します。最高のコードは最もエレガントで洗練されたものではありません - 将来の開発者（あなた自身を含む）が迅速に理解できるコードです。</p>
    <p>あなたの記事は、ブラウザ開発で私たちが直面する課題と本当に共鳴します。認知負荷について言った多くのポイントと完璧に一致する、現代のブラウザが最も複雑なソフトウェアシステムの一つであることについて、あなたは絶対に正しいです。</p>
    <p>Chromiumでこれを処理しようとする一つの方法は、慎重なコンポーネント分離とサブシステム間（レンダリング、ネットワーキング、JavaScript実行など）の明確に定義されたインターフェースです。Unix I/Oでの深いモジュールの例と似ています - 比較的シンプルなインターフェースの背後にある強力な機能を目指しています。例えば、私たちのレンダリングパイプラインは信じられないほどの複雑性（レイアウト、合成、GPUアクセラレーション）を処理しますが、開発者は明確な抽象化レイヤーを通してそれと相互作用できます。</p>
    <p>不要な抽象化を避けることについてのあなたのポイントも本当に心に響きます。ブラウザ開発では、新しい貢献者にとってコードベースをアプローチしやすくすることとウェブ標準と互換性の本質的な複雑性を処理することの間で常にバランスを取っています。</p>
    <p>時には、複雑なシステムであっても、最も単純な解決策が最良の解決策です。</p>
    <p><strong><a href="https://x.com/antirez" target="_blank">antirez</a></strong> <i>(Redis)</i><br>それについて完全に同意します :) また、私が信じているのは、言及された「A Philosophy of Software Design」から欠けているのは「設計犠牲」の概念です。つまり、時には何かを犠牲にして、シンプルさ、またはパフォーマンス、またはその両方を取り戻すのです。私はこのアイデアを継続的に適用していますが、しばしば理解されません。</p>
    <p>良い例は、私がハッシュアイテムの期限切れを持つことを常に拒否したことです。これは設計犠牲です。なぜなら、特定の属性をトップレベルアイテム（キー自体）にのみ持つ場合、設計はよりシンプルになり、値は単なるオブジェクトになります。Redisがハッシュ期限切れを得たとき、それは良い機能でしたが、実際に多くの部分に多くの変更を必要とし、複雑性を高めました。</p>
    <p>別の例は、私が今やっていること、Vector Sets、新しいRedisデータタイプです。私はRedisがベクトルについての真実の源ではなく、それらの近似版を取ることができるだけであると決定したので、ディスク上の大きなフロートベクトルを保持しようとすることなく、挿入時の正規化、量子化を行うことができました。多くのベクトルDBは、ユーザーが入れたもの（完全精度ベクトル）を覚えているという事実を犠牲にしません。</p>
    <p>これらは単なる2つのランダムな例ですが、このアイデアをどこでも適用しています。今のことは：もちろん正しいものを犠牲にしなければなりません。しばしば、非常に大きな複雑性を占める5％の機能があります：それを殺すのは良いことです :D</p>
    <p><strong><a href="https://working-for-the-future.medium.com/about" target="_blank">インターネットからの開発者</a></strong><br>あなたは私を雇わないでしょう... 私はリリースされたエンタープライズプロジェクトの実績で自分を売り込みます。</p>
    <p>設計パターンを話すことができる人と働いたことがあります。私はそのように話すことは決してできませんでしたが、彼を理解できる数少ない人の一人でした。マネージャーは彼を愛し、彼はあらゆる開発会話を支配することができました。彼の周りで働く人々は、彼が後ろに破壊の跡を残していると言いました。私は彼のプロジェクトを理解できる最初の人だと言われました。メンテナビリティは重要です。私は最もTCOを気にします。いくつかの企業にとって、それが重要なことです。</p>
    <p>しばらくGithubに行っていなかった後にログインし、なぜか無作為に見える誰かによるリポジトリ内の記事に連れて行かれました。「これは何だ」と思って、ホームページにたどり着くのに少し問題があったので、それを読みました。その時は実際には登録していませんでしたが、それは素晴らしいものでした。すべての開発者が読むべきです。それは基本的に、プログラミングのベストプラクティスについて私たちが言われてきたことのほぼすべてが過度の「認知負荷」につながると言っていました。つまり、私たちの心が知的要求によって蹴られているということです。私はしばらくの間これを知っていました、特にクラウド、セキュリティ、DevOpsの要求で。</p>
    <p>また、それが何十年もやってきた実践について説明していたので気に入りました、しかし人気がないためにあまり認めることはありません... 私は本当に複雑なものを書き、すべてのヘルプが得られる必要があります。</p>
    <p>考えてみると、私が正しければ、それはGithubの人々、非常に賢い人々が開発者がそれを見るべきだと思ったために現れました。私も同意します。</p>
    <p><a href="https://news.ycombinator.com/item?id=45074248" target="_blank">Hacker Newsのコメント</a> (<a href="https://news.ycombinator.com/item?id=42489645" target="_blank">2</a>)</p>
</details>
