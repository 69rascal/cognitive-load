# 认知负荷才是关键

## 简介(Introduction)

这世上有如此多的流行术语和最佳实践，但它们中大多数无法真正落地。因此，让我们把注意力转向更根本的方面，比方说，开发者在阅读代码时所感受到的“困惑程度”。

困惑是以时间和金钱为代价的。困惑源于过高的*认知负荷*。这不是什么花哨的抽象概念，而是**一种基本的人类限制**。它不是靠想象出来的，而是真实存在，能被感知的。

由于我们日常花在阅读和理解代码上的时间远远多于编写代码的时间，所以我们应该经常自省：我们是否在代码里添加了过多会给人带来认知负荷的内容。

## 认知负荷(Cognitive load)

> “认知负荷”（Cognitive load）指的是开发者为了完成一项任务而需要投入的思考量。

在阅读代码时，人们会将诸如变量值、控制流逻辑和调用序列等内容记在脑海里。通常情况下，一般人在[工作记忆](https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BF%86/5197761)中大约可以保存[四个信息块](https://github.com/zakirullin/cognitive-load/issues/16)。一旦认知负荷达到这个临界值，理解事物就变得更加困难。

*假设我们被要求对一个完全不熟悉的项目进行修复工作。我们被告知在此之前，有一位非常聪明的开发人员贡献过这个项目，并在里面应用了许多复杂高级的架构、花哨的库和流行的技术。换句话说，**这位开发人员给我们制造了很高的认知负荷。***

<div align="center">
  <img src="/img/cognitiveloadv6.png" alt="Cognitive load" width="750">
</div>

我们应该尽可能地减少项目中会给人带来认知负荷的内容。

## 认知负荷的类型(Types of cognitive load)

**内在的** —— 由任务本身所固有的难度造成的。它是软件开发的核心要素，且这种难度无法降低。

**外在的** —— 由信息的呈现方式造成的。它由一些与任务本身无关的因素产生的，比如那些聪明人的 “骚操作”。这种类型的认知负荷是可以大幅减少的。我们将在下文着重关注这一类型的认知负荷。

<div align="center">
  <img src="/img/smartauthorv14thanksmari.png" alt="Intrinsic vs Extraneous" width="600">
</div>

接下来让我们直接看一些“外在的”认知负荷的具体实例。

---

我们将认知负荷的程度定义如下：

`🧠`: 刚初始化的“工作记忆”，此时不存在认知负荷

`🧠++`: 在“工作记忆”中放入了两项内容，认知负荷有所增加（`+`越多，负荷越多）

`🤯`:在“工作记忆”中放入了超过4项内容，致使“工作记忆” 出现 “溢出” 状况

> 我们的大脑实际要更加复杂而神秘，这里只是运用这个简单模型对认知负荷的程度进行简要描述。

## 复杂的条件控制(Complex conditionals)

```go
if val > someConstant // 🧠+
    && (condition2 || condition3) // 🧠+++, 前一个条件必须是 true, c2 和 c3 中的任意一个应该为 true
    && (condition4 && !condition5) { // 🤯, 然后我们就被这个地方整懵逼了
    ...
}
```

我们可以通过命名语义化的中间变量来降低认知负荷：
```go
isValid = val > someConstant
isAllowed = condition2 || condition3
isSecure = condition4 && !condition5
// 🧠，我们无需记住这些判断条件，因为这些变量名称是自描述的
if isValid && isAllowed && isSecure {
    ...
}
```

## 多层嵌套的 ifs (Nested ifs)

```go
if isValid { // 🧠+, 这一步我们目前只关心 isValid 这一个变量（是否有效）
    if isSecure { // 🧠++, 这一步我们要同时关心 isValid 和 isSecure 两个变量（是否有效并且安全）
        stuff // 🧠+++
    }
}
```

和“提早返回”（先判断条件不满足时直接返回）做对比：

```go
if !isValid
    return

if !isSecure
    return

// 🧠, 我们不用去关心已经返回的东西，走到这一步代表所有校验已经通过

stuff // 🧠+
```

通过这种写法，我们可以专注于主流程，从而使“工作记忆”从各种先决条件中解放出来。

## 多继承噩梦 (Inheritance nightmare)

我们接到要求，要针对管理员用户对某些内容进行修改 `🧠`：

`AdminController extends UserController extends GuestController extends BaseController`

噢，一部分的功能代码在`BaseController`，让我们来看看：`🧠+`

在`GuestController` 中引入了基本的角色机制：`🧠++`

在`UserController` 中修改了部分内容：`🧠+++`

终于，我们来到了`AdminController`，让我们开始编码吧！：`🧠++++`

Oh，等下，这里还有一个`SuperuserController`，它继承自`AdminController`。如果修改了`AdminController`，我们可能会破坏继承类中的功能，所以我们要先了解一下`SuperuserController`：`🤯`

这里推荐使用组合而非继承来实现功能。关于这一点，这里就不详细阐述了 —— [参考资料](https://www.youtube.com/watch?v=hxGOiiR9ZKg)有很多。

## 存在数量过多的小方法，类或模块(Too many small methods, classes or modules)

> 在下述描述中，方法、类和模块的术语是可以相互替换的。

诸如 “方法应该少于 15 行代码” 或 “类应该很小” 之类的观点，经实践证明是存在一定错误的。

**深模块**（Deep module）—— 接口简单，内部实现复杂的

**浅模块**（Shallow module）—— 接口相对于自身所提供的（简单）功能而言相对复杂

<div align="center">
  <img src="/img/deepmodulev8.png" alt="Deep module" width="700">
</div>

倘若项目中存在过多的浅模块，项目就会变得晦涩难懂。**因为人们不仅要记住每个模块所承担的职责，还要记住它们之间的所有交互关系**。为了弄明白浅模块的用途，我们首先得查看所有与之相关的模块的逻辑。`🤯`

> [信息隐藏](https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/3230616)至关重要，当然我们并不会在浅模块中隐藏大量复杂性。

举个真实例子，我有两个业余项目，每个项目都有约 5 千行代码。第一个项目包含 80 个浅类（shallow class），而第二个项目仅有 7 个深类（deep class），我已经有一年半没对这两个项目进行维护了。

有一次我回过头来维护项目，我发现要理清第一个项目中那 80 个类之间的所有交互关系，简直难如登天。在我开始编码之前，我不得不重新构建大量的认知负荷。而至于第二个项目，我能迅速理解上手，因为它只包含几个有着简单接口的深类。

> 最优秀的组件既能够提供强大的功能，又具有简单易用的接口设计。
>
> **John K. Ousterhout**

UNIX I/O 的接口就非常简单。它只有五个基本调用：

```c
open(path, flags, permissions)
read(fd, buffer, count)
write(fd, buffer, count)
lseek(fd, offset, referencePosition)
close(fd)
```

事实上，这个接口的实现多达**数十万行代码**。大量的复杂性被隐藏在内部。不过因为接口设计简单，所以使用起来依然很便捷。

> 这个深模块的示例源于 John K. Ousterhout 的 [《软件设计的哲学》](https://web.stanford.edu/~ouster/cgi-bin/book.php)一书。这本书不仅涵盖了软件开发中复杂性的核心，还对 Parnas 颇具影响力的论文 [《分解系统模块的标准》](https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf)进行了最佳的诠释。这两本书都是必读之作。其他相关阅读包括：[可能是时候停止推荐《代码整洁之道》了](https://qntm.org/clean)、[小函数可能是有害的](https://copyconstruct.medium.com/small-functions-considered-harmful-91035d316c29)。

附注：如果你认为我们是在支持那种臃肿且承担过多职责的“万能对象”，那你就误解了。

## 浅模块和单一职责原则(Shallow modules and SRP)

很多时候，我们会遵循“一个模块应该只负责一件事”这一模糊的原则，最终创建出大量浅模块。可这“一件事”究竟指的是什么？比如实例化一个对象也算是“一件事”，对吧？如此看来，像 [MetricsProviderFactoryFactory](https://minds.md/benji/frameworks) 这样的模块似乎并无不妥。然而，这样的类名和接口往往比其本身实现更令人费解，这到底是一种怎样的抽象呢？显然有一些不对劲的地方。

> 在这些浅组件（Shallow components）之间来回切换是非常耗费心力的，[线性思维](https://blog.separateconcerns.com/2023-09-11-linear-code.html)对于我们人类来说是更自然的思维方式。

我们对系统的更改是为了满足用户和利益利益相关方的需求，我们对他们负责。

> 一个模块应当有且只对一个特定的用户或者利益相关方负责。

这才是单一职责原则的真正含义。简单来说，如果我们在某个地方引入了一个 bug，随后有两个不同业务模块的人员都来投诉，那就意味着我们违反了这个原则。它与我们在模块中做了多少事情无关。

但就目前而言，这种解释仍然可能造成更多的误解。每个人对这一条规则的理解也可能不一样。因此，更好的判断模块是否遵循单一职责的方法是看其带来了多少认知负荷。像记住一个模块的变化会引发一系列业务流的连锁反应是需要一定心智负担的。这才是重点。

## 过多的“浅微服务”(Too many shallow microservices)

浅模块与深模块与可扩展性无关，所以我们还能够把这个原理运用到微服务架构中。过多的浅微服务（shallow microservices）并无益处 —— 行业发展趋势正朝着“宏服务”方向发展，即不那么浅的服务（=深服务）。在微服务架构里，最糟糕且最难解决的现象之一是所谓的分布式单体，它通常是过度细化拆分颗粒度所导致的结果。

举个真实的例子，我曾经为一家初创公司提供咨询服务，这家公司团队仅有五名开发人员，却创建了 17 个微服务！问题在于项目的进度比计划落后了将近10个月，并且距离正式发布上线还有很长的路要走。每当有新需求出现，就会涉及4个或者更多的微服务需要修改。这导致在进行集成联调时，排查问题的难度也是急剧上升。上线所需时间和开发人员的认知负荷都高到令人难以接受。`🤯`

这是应对新系统不确定性的正确方式吗？一开始就期望找到正确的逻辑边界是极为困难的。关键在于要尽量推迟做决策，因为越到后期，可供参考的信息就越多，从而能更好地做出决策。如果我们一开始就引入网络层，之后再想修改这个设计就会变得极其艰难。然而，该团队使用此架构的唯一理由是：“FAANG（脸书、亚马逊、苹果、网飞和谷歌）这些公司已经证实了微服务架构是行之有效的”。*醒醒吧，别再做不切实际的美梦了*。

[Tanenbaum-Torvalds 辩论](https://en.wikipedia.org/wiki/Tanenbaum%E2%80%93Torvalds_debate)指出 Linux 的单体设计是有缺陷并且过时的，应该用微内核架构取而代之。确实，从“理论和美学”的角度来看，微内核设计似乎更优越。但从实践的角度来看 —— 三十年过去了，基于微内核的 GNU Hurd 仍在开发中，而采用单体结构的 Linux 无处不在。你现在浏览的页面运行在 Linux 之上，你的智能茶壶也是由 Linux 系统提供支持的。（正是单体结构的 Linux）。

经过精心设计且拥有真正隔离模块的单体系统，在很多情况下会比由众多微服务组成的架构更加灵活。同时，维护这样的单体系统所需的认知成本要低得多。只有在单独部署的需求至关重要的情况下，例如扩展开发团队，才应该去考虑在模块之间添加网络层，逐步转向未来的微服务。

## 具有强大特性和功能的语言(Feature-rich languages)

当我们特别喜爱的某种编程语言发布新特性时，我们往往会兴奋不已。随后，我们会花些时间去学习这些新特性，并在编码时运用他们。

要是一门语言的新特性众多，我们可能会花上半小时去尝试写几行代码以使用这些特性，这着实有些浪费时间。然而更糟的是，当你日后再回过头来看这些代码时，你还得重新构建当时的思路！

**你不但需要理解这个复杂的程序，还需要理解为什么开发人员选择用这些特性来解决问题。**`🤯`

这些内容是 Rob Pike 提出的。

> 通过减少可选项来降低认知负荷。

使用语言特性并无不妥，前提是它们彼此独立（正交，在这里表示语言特性之间相互独立，不会相互干扰或冲突）。

<details>
  <summary><b>一位拥有20年C++经验的工程师的想法 ⭐️</b></summary>
  <br>
  前几日，当我浏览我的 RSS 阅读器时，留意到 “C++” 标签下竟有约三百篇未读文章。从去年夏天至今，我未曾读过一篇有关 “C++” 的文章，而这种感觉棒极了！<br><br>
  到目前为止，我使用C++已达 20 年之久，这几乎占据了我人生三分之二的时光。我的大部分经验都耗费在处理它那些最为晦涩难懂的部分上（比如各种各样的未定义行为）。这是一种无法复用的经验，如今要将这些经验全部抛开，这种感觉有点令人不安。<br><br>
  举个例子，你能想象吗？<code>||</code>在<code>requires ((!P<T> || !Q<T>))</code> 和 <code>requires (!(P<T> || Q<T>))</code>中有不同的含义。第一种情况是约束析取（constraint disjunction），第二种情况则是常见的逻辑或（logical OR）运算符，并且它们的行为并不一致。<br><br>
  在 C++20 之前，对于普通类型（trivial type），不能简单地分配空间后直接使用<code>memcpy</code>复制一组字节 —— 这样不会启动对象的生命周期。在 C++20 中，这个问题得到了解决，但语言的认知负荷却不降反增。<br><br>
  认知负荷在不断增加，即便问题已经得到了处理。作为专业人士，我需要了解哪些问题被修复了、何时修复以及修复之前的情况。当然，C++ 在兼容遗留代码方面做得很好，但这也意味着你<b>不得不面对</b>那些遗留代码产生的遗留问题。例如，上个月我的一位同事向我询问了 C++03 中的一些代码行为。<code>🤯</code><br><br>
  曾经有 20 种初始化方式。然后统一初始化语法被添加了进来。现在我们有 21 种初始化方式。顺便问一下，有人还记得从初始化列表中选择构造函数的规则吗？是关于以信息损失最小的方式进行隐式转换，<i>但是如果</i>值是静态已知的，那么……<code>🤯</code><br><br>
  <b>这种增加的认知负荷并非源于手头的业务任务，也不是领域内在的复杂性所致。仅仅是由于历史原因而存在</b>（<i>外在认知负荷</i>）<br><br>
  我不得不制定一些规则。比如，如果某行代码不是很明显易理解，并且我需要记住特定标准时，那么最好不要那样编写代码。顺带一提，标准大概有 1500 页长。<br><br>
  <b>我绝不是在指责 C++。</b>我热爱这种语言。只是我现在有些累了。
</details>

## 业务逻辑和HTTP状态码(Business logic and HTTP status codes)

在后端，我们返回以下内容：

`401` 表示jwt令牌已经过期

`403` 表示访问权限不足

`418` 表示用户被禁用

前端开发人员利用后端的 API 来实现登录功能时，不得不暂时在大脑中承担以下认知负荷：

`401` 表示jwt令牌过期 // `🧠+`，好吧只是暂时在脑子里记一下。

`403` 表示访问权限不够 // `🧠++`

`418` 表示用户被禁用 // `🧠+++`

前端开发人员将（希望）在他们代码中引入某种 “数字状态码 -> 含义” 的映射字典，这样后续的开发人员就无需在脑海中重现构建这种映射关系了。

接着，QA人员参与到项目中：“嘿，我收到了`403`状态码，这是令牌过期了还是权限不足呢？”
**QA 人员无法直接开展测试工作，因为他们首先得重新梳理后端人员创建的认知负荷。**

我们为什么要在工作记忆中保留这种自定义映射呢？更好的做法是将业务细节从 HTTP 传输协议中抽象出来，直接在响应正文中返回具有自描述性质的状态码，比如：

```json
{
    "code": "jwt_has_expired"
}
```

如此一来，前端开发人员的认知负荷：`🧠`（清空状态，脑中无需记住任何信息）
QA 人员的认知负荷：`🧠`

同样的规则适用于所有类型的数字状态码（无论在数据库中还是其他任何地方）。**优先使用自描述的字符串**。毕竟，现在早已不是需要为仅有 640K 内存的计算机优化内存使用的时代了。

> 人们常常花费时间在 `401` 和 `403` 的含义区别上争论不休，并且依据各自的理解来做出决定。每当有新的开发人员加入，他们需要建立新的思维过程。或许你已经为代码的 “设计决策原因”（ADRs）做了文档记录，以便新人理解当初你们做的决定。但到头来，这样的方式没有任何意义。我们虽然能够明确地把错误划分成“用户相关”和“服务器相关”的类型。但在这两种类型之外，错误的归属和原因就变得模糊不清了。

附注：区分 “认证”（authentication）和 “授权”（authorization）通常是一种精神负担。我们可以使用更简单的术语，如 [“登录”（login）和 “权限”（permissions）](https://ntietz.com/blog/lets-say-instead-of-auth/)来降低认知负荷。

## 滥用 DRY 原则(Abusing DRY principle)

不要重复编写相同的代码 —— 这是你在软件工程师的学习和工作过程中，被反复灌输的重要原则之一。它植根于我们的观念当中，以至于我们对代码冗余几乎零容忍，哪怕只有几行的重复代码也不行。总体而言，它是一个很好的基本原则，但过度遵循它可能会带来过多的认知负荷，令我们不堪重负。

当前，人们构建软件时通常基于逻辑分离的组件。这些一般分布在多个代码库中，代表着不同的服务。在你努力消除重复的过程中，可能会使原本不相关的组件变得紧密耦合。这样一来，后续对某个部分的修改可能会在其他看似毫无关联的地方引发意想不到的后果。同时，这也会削弱在不影响整个系统的前提下替换或修改单个组件的能力。`🤯`

事实上，即使在单个模块内部，也会出现类似的问题。你可能会依据自己主观感觉上的相似性（但长远来看可能并不存在）来过早地提取通用功能。而这样做可能会产生不必要的抽象，进而使得软件变得难以修改或扩展。

Rob Pike 曾经说过：

> 适当的复制要优于不必要的依赖。

我们往往不愿重造轮子，但却为了使用现成的实现而去引入大型且复杂的库，尽管这些简单功能我们自己也能轻松实现。

**你所依赖的所有库都如同你的代码。** 当出现问题时，如果你需要追踪某个依赖库 10 层以上的堆栈来排查问题，那是很痛苦的。

## 与框架紧密耦合(Tight coupling with a framework)

框架中存在着许多 “魔法”。如果我们过于依赖框架，**就会迫使所有后续的开发人员首先去学习这些 “魔法”**。而这一过程可能耗时数月之久。虽然框架可以帮助我们在短短几天内启动 MVP【最小可行产品】，但长远来看，它们往往会徒增不必要的复杂性和认知负荷。

更糟的是，在某些情况下，当出现一个与现有架构不匹配的新需求时，框架很可能会成为需求实现的最大阻碍。自此，人们会在当前框架基础上开辟新的分支，并维护一个定制版本。设想一下，对于一个新加入的成员，为了能够开展工作，需要承受多大的认知负荷（即学习这个定制版本的框架）。`🤯`

**但这绝不意味着我们提倡所有东西都从零开始开发！**

我们可以采用不受特定框架束缚的方式来编写代码。例如，业务逻辑不应该被放置在框架内部；相反，它应该通过调用框架所提供的组件来实现。我们可以在核心业务逻辑之外搭建一个框架，用来处理一些通用功能。这样一来，其他开发人员就能够像使用类库一样调用这个框架。这样做能够让新加入的成员从一开始就能投入工作，而不必先去了解和框架相关的复杂内容。

> [为什么我讨厌“框架”](https://minds.md/benji/frameworks)

## 分层架构(Layered Architecture)

在工程学领域，这些架构确实能激发一种独特的兴奋感。

多年来，我一直热衷于提倡洋葱架构（Hexagonal/Onion Architecture）。在诸多项目中，我都运用了这一架构，并且还积极鼓动其他团队也采用。然而，随着项目复杂性大幅增加，光是文件数量就翻了一番。很多时候，我们感觉自己在编写大量的“胶水代码”。随着需求的持续变更，我们不得不对多层抽象结构进行修改，整个开发过程变得枯燥、乏味。`🤯`

抽象的目的是隐藏复杂性，但在这里，它只是增加了[间接性](https://fhur.me/posts/2024/thats-not-an-abstraction)。从一个调用跳转到另一个调用，不断地阅读和分析以确定问题所在——这是快速解决问题的必要要求。在使用这种洋葱架构多层解耦的情景下，在寻找故障具体位置过程中，可能需要追踪众多看似毫无关联的线索，而且这些线索呈指数级增长的。每一次这样的跟踪都会占用我们有限的工作记忆空间。`🤯`

这种架构乍一看在直觉上是合理的，但每次当我们在项目中尝试应用时，总会发现其弊大于利。最终，我们彻底放弃了洋葱架构，转而支持经典的依赖倒置原则（Dependency Inversion Principle）。如此一来，我们**无需学习端口 / 适配器概念，也不用引入不必要的水平抽象层，从而避免了无关的认知负荷。**

倘若你认为这种分层方式能够让你迅速地更换数据库或者其他的依赖对象，那就大错特错了。更改存储往往会引发诸多问题，相信我们，对数据访问层进行抽象往往是最不该考虑的事情。即便是在最好的情况下，抽象或许能节省 10% 的迁移时间（如果有的话），但真正难点在于数据模型的不兼容、通信协议问题、分布式系统挑战以及[隐式接口](https://www.hyrumslaw.com/)。

> 一旦一个 API 拥有足够多的用户，
> 契约中承诺的内容就变得无关紧要：
> 系统的所有可观察行为
> 都会被某些人所依赖。

我们做过一次存储迁移，花了大约 10 个月的时间。旧系统是单线程的，因此暴露的事件是顺序的。我们的所有系统都依赖于这种行为。但这个行为并不在 API 合约中，也没有在代码中体现出来。新的分布式存储没有这种保证——这意味着事件是乱序的。我们花了几个小时编写了一个新的存储适配器，但接下来的 10 个月，我们都在处理乱序事件和其他挑战。现在回头看，说分层架构能帮助我们快速更换组件就很搞笑。

**所以，如果这种架构在未来不能带来回报，我们又为什么要为其承担高认知负荷的代价呢？** 而且，在大多数情况下，未来可能根本不会出现更换某些核心组件的需求。

这些架构并非最基础的架构，它们是在更基础的架构基础上，因主观和偏见而产生的。我们为何要遵循这些主观偏见呢？更好的做法是：遵循依赖倒置原则、重视认知负荷和信息隐藏这些基础架构理念。[可点击这里参与讨论](https://github.com/zakirullin/cognitive-load/discussions/24)

不要为了架构而盲目添加抽象层。只有当你出于实际需求且需要合理扩展时才考虑添加。

[抽象层并非毫无代价的](https://blog.jooq.org/why-you-should-not-implement-layered-architecture)，**它们会占据我们的工作记忆空间**

<div align="center">
  <img src="/img/layers.png" alt="Layers" width="400">
</div>

## 领域驱动设计(DDD)

尽管领域驱动设计（Domain-driven design，缩写为 DDD）常常遭受误解，但其在某些方面的确有卓越之处。人们通常说的 “我们用 DDD 写代码”，这种说法其实是有些奇怪的，因为 DDD 是和问题空间（problem space）相关的，而不是和解决方案空间（solution space）相关的。

> 译注：
>
> - problem space: 问题空间，简单理解就是当前环境下业务所面临的一系列问题和背后的需求。
>
> - solution space: 解决方案空间，则是针对问题空间的解决方案，它思考的是如何设计实现软件系统以解决这些问题，它属于工程设计实施阶段，通常是技术专家主导的解决方案设计和实现。

无处不在的语言、领域、有界上下文（bounded context）、聚合、事件风暴（event storming）等概念都属于问题空间的范畴。它们旨在协助我们洞察领域并确定其边界。DDD 能够让开发人员、领域专家和业务人员使用一种统一的语言来实现高效沟通。然而，我们往往侧重于特定的文件夹结构、服务、存储库以及其他解决方案空间的技术，却忽视了 DDD 在问题空间上的问题。

我们对 DDD 的阐释很有可能具有独特性和主观性。如果我们依照这种理解来构建代码（即如果我们制造了很多无关的认知负荷）—— 那么未来接手的开发人员注定要完蛋。`🤯`

## 示例(Examples)

- 我们的架构是标准的 CRUD 应用架构，是[基于Postgres 的 Python 单体应用](https://danluu.com/simple-architectures/)
- Instagram 如何在仅有 [3 名工程师](https://read.engineerscodex.com/p/how-instagram-scaled-to-14-million) 的情况下，将用户规模扩展到的 1400 万的呢？
- 我们喜爱的公司 “哇，这些人 [聪明绝顶](https://kenkantzer.com/learnings-from-5-years-of-tech-startup-code-audits/)” ，却在很大程度上遭遇了失败。
- 用一个函数连接整个系统。如果你想知道系统是如何运作的 —— [请阅读](https://www.infoq.com/presentations/8-lines-code-refactoring)

这些架构相当枯燥，也很容易理解，任何人都能轻松掌握，无需耗费太多脑力。

安排初级开发人员参与架构审查。他们会助力你识别出那些对心智要求颇高的代码。

## 熟悉的项目中的认知负荷(Cognitive load in familiar projects)

> 问题在于，熟悉并不等同于简单。二者给人的*感觉*看似是一样的 —— 都能让人不用费太多脑力就能轻松地在代码之间穿梭 —— 但原因却截然不同。你所使用的每一个 看似“聪明”（实则是“自我放纵”）和非惯用的技巧，都会让其他人付出学习的代价。一旦他们完成学习，他们会发现与代码打交道变得不那么困难。因此，要认识到如何去简化自己已经熟悉的代码并非易事。这就是为什么我尽量让“新手”在他们还没完全融入之前先评价项目代码！
>
> 这巨大混乱的项目代码很可能是之前的开发人员一点点造就出来的，而不是一次性创造出来的。而你是第一个不得不一次性理解它的人。
>
> 在我的课堂上，我曾描述过我们有一天见到的一个庞大的 SQL 存储过程，其巨大的 WHERE 子句中包含了数百行条件语句。有人问，怎么会有人能把它弄得如此糟糕。我告诉他们：“当只有两三个条件语句时，再添加一个似乎没有影响。当有二三十个条件语句时，再另添加一个看起来也没差！”
>
> 除了你有意为之的选择之外，代码库并不会受到任何 “简化之力”的作用。简化需要付出努力，然而人们却经常无暇顾及。
>
> *感谢 [Dan North](https://dannorth.net)的评论*。

如果你已经将这个项目的心智模型内化到长期记忆中，你就不会承受高认知负荷。

<div align="center">
  <img src="/img/mentalmodelsv15.png" alt="Mental models" width="700">
</div>

需要学习的心智模型越多，新手投入工作前熟悉项目所需的时间就越长，这也意味着更晚才能为项目创造价值。

每当你给新人做入职培训的时候，可以尝试去衡量他们的困惑程度（结对编程或许会有所帮助）。倘若他们持续困惑的时间超过 40 分钟，—— 这意味着你的代码存在需要改进的地方。

若你能让项目保持较低的认知负荷，那么新人有可能在入职后的最初几个小时内，就能为公司的代码库贡献力量。

## 结论(Conclusion)

想象一下，我们在第二章中推断的并非真实情况。倘若如此，那么我们刚刚否定的结论，以及上一章中我们认为有效的结论，或许也不是正确的。`🤯`

你感觉到了吗？你不仅需要在文章中来回跳转才能理解其含义（浅模块！），而且段落总体上也很难理解。我们刚刚在你的脑海中制造了不必要的认知负荷。**请不要对你的同事这样做。**

<div align="center">
  <img src="/img/smartauthorv14thanksmari.png" alt="Smart author" width="600">
</div>

我们应当减少一切超出工作本身所带来的认知负荷。

---
[LinkedIn](https://www.linkedin.com/in/zakirullin/), [X](https://twitter.com/zakirullin), [GitHub](https://github.com/zakirullin)

[Readable version](https://zakirullin.md/cognitive)

<details>
  <summary><b>认知负荷与干扰因素(Cognitive load and interruptions)</b></summary>
  <img src="img/interruption.jpeg"><br>
</details>
<details>
  <summary><b>编码原理和经验(Coding principles and experience)</b></summary>
  <img src="img/complexity.png"><br>
  <a href="https://twitter.com/flaviocopes">@flaviocopes</a>
</details>
